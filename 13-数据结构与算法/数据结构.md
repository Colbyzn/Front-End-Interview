# Front-End-Interview::13-数据结构与算法::数据结构

## 请介绍一下算法复杂度

<!-- notecardId: 1706284194642 -->

🔍 所考察的知识点：

📢 参考答案：

### 定义

- 算法复杂度包含时间复杂度和空间复杂度，描述了程序被执行时，所需**计算量**和**内存空间**在**不同规模输入下的表现**

  > 注：**计算量，即执行时间，对应时间复杂度，内存空间对应空间复杂度**

- 算法复杂度**与代码书写是否简洁无关**

  > 注：例如，for 循环语句，循环 10 亿次，这样的代码**虽然书写上很简洁，但是所需的计算量惊人**

- 算法复杂度是**数量级**的，并不是具体的数字

  > 注：**同一单位为同一数量级**，例如，2 厘米与 8 厘米为同一数量级、2 厘米与 1 米 就是不同数量级

- 算法复杂度一般**针对一个具体的算法**，而不是一个完成系统的复杂度

  > 注：例如，算法复杂度**不管系统中网路的耗时、硬盘读取的耗时**，只考虑计算量和内存空间的耗时

### 为什么需要

- 因为有了算法复杂度，我们就可以估计**算法在不同规模数据输入下的表现**，有利于我们**了解算法的性能瓶颈**，以便**根据不同应用场景选择合适的算法处理问题**

### 基本使用

### 使用注意

1. 分析算法复杂度时，要关注**最坏情况下**的复杂度
2. 使用大 O 表示法时，最终结果**忽略掉常数因子和低阶项，只保留最高阶项**
   > 注：例如，如果基本操作执行次数为 3n^2 + 2n + 1，那么时间复杂度为 O(n^2)

## 请介绍一下大 O 表示法

<!-- notecardId: 1706284194648 -->

📢 参考答案：

### 定义

- 大 O 表示法是**表示算法复杂度的一种方法**，它**将算法按照所需计算量（即消耗时间）或者内存空间进行分类**

### 为什么需要

- 因为大 O 表示法提供了几类**函数**来表示不同算法的复杂度，有了它，你才能通过一种方式来**表示不同算法的复杂度**

### 常用大 O 表示符号

![](../Media/%E5%B8%B8%E7%94%A8%E5%A4%A7%20O%20%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%8F%B7.png)

### 基本使用

#### 常用的时间复杂度

1. **常数时间复杂度 O(1)**

   表示算法的**计算量是常数，与输入数据量无关**

   ```javascript
   function constantTime() {
     return [...arguments];
   }
   ```

   > 注：上述示例中，调用函数时，**不管传入多少数据，将 arguments 对象转换为数组）也只执行 1 次**，与输入数据量无关

2. **对数时间复杂度 O(log(n))**

   表示算法的**计算量与输入数据量成对数关系**，例如，输入 100 个数据，最坏情况下，计算量为 10 次

   ```javascript
   function binarySearch(arr, target) {
     let low = 0,
       high = arr.length - 1;
     while (low <= high) {
       let mid = Math.floor((low + high) / 2);
       if (arr[mid] === target) {
         return mid;
       } else if (arr[mid] < target) {
         low = mid + 1;
       } else {
         high = mid - 1;
       }
     }
     return -1;
   }
   ```

   > 注：上述示例是**二分查找算法**，是一个典型的对数时间复杂度例子，它通过二分查找算法**在有序数组中**查找目标元素，**每一次迭代都将候选范围减半**

3. **线性时间复杂度 O(n)**

   表示算法的**计算量与输入数据量一样**

   ```javascript
   function linearTime(arr) {
     arr.forEach((item) => {
       console.log(item);
     });
   }
   ```

   > 注：上述示例是**单层循环**，遍历数组的每一个元素，并对每个元素执行一次打印操作，数组元素有几个，就打印几次

4. **线性对数时间复杂度 O(nlog(n))**

   表示算法的**计算量与输入数据量呈线性对数关系**

   ```javascript
   function mergeSort(arr) {
     if (arr.length <= 1) {
       return arr;
     }
     const mid = Math.floor(arr.length / 2);
     const left = mergeSort(arr.slice(0, mid));
     const right = mergeSort(arr.slice(mid));
     return merge(left, right);
   }

   function merge(left, right) {
     let result = [];
     let i = 0,
       j = 0;
     while (i < left.length && j < right.length) {
       if (left[i] < right[j]) {
         result.push(left[i]);
         i++;
       } else {
         result.push(right[j]);
         j++;
       }
     }
     return result.concat(left.slice(i)).concat(right.slice(j));
   }
   ```

   > 注：上述示例是排序算法，是一个典型的线性对数时间复杂度，它包含**一个单层循环和一个二分法**，它将数组拆成两半，然后递归地对每一半进行排序，最后将它们合并，由于每次递归都将数组分为两半，所以时间复杂度为 nlog(n)

5. **平方时间复杂度 O(n^2)**

   表示算法的**计算量是输入数据量的平方**

   ```javascript
   function quadraticTime(matrix) {
     const rows = matrix.length;
     const cols = matrix[0].length;
     for (let i = 0; i < rows; i++) {
       for (let j = 0; j < cols; j++) {
         console.log(matrix[i][j]);
       }
     }
   }
   ```

   > 注：上述示例，使用**双层嵌套循环**来遍历二维矩阵，其中外层循环遍历行，内层循环遍历列，每层循环都会执行 n 次，所以总共是 `n * n = n^2`

#### 常用的空间复杂度

1. **常数空间复杂度 O(1)**
   表示算法所需的内存空间与输入数据量无关

   ```javascript
   function constantSpace(array) {
     let sum = 0;
     for (let i = 0; i < array.length; i++) {
       sum += array[i];
     }
     return sum;
   }
   ```

   > 注：上述例子中，**无论输入数组的大小如何**，我们**只需要一个额外的变量 `sum` 来存储总和**，所以空间复杂度是 O(1)。

2. **线性空间复杂度 O(n)**
   表示算法所需的内存空间随输入数据量线性增长

   ```javascript
   function linearSpace(arr) {
     let newArr = [];
     for (let i = 0; i < arr.length; i++) {
       newArr[i] = arr[i];
     }
     return newArr;
   }
   ```

   > 注：上述示例中，**传入数组的长度会影响到函数内返回值数组 newArr 的长度**，所需空间与传入数组的数据量成正比，因此，空间复杂度为 O(n)

### 使用注意

1. 写代码时，要**对算法复杂度敏感**，否则很容易出现编写的代码能实现功能，但是输入数据量一大，就崩溃的情况
2. **前端领域重时间轻空间**，所以要多关注时间复杂度，而空间复杂度一般是做嵌入式开发的人员要多关注的，因为搭载的小型系统内存小
3. 时间复杂度若为 **O(n^2)**，则该算法**不可用**

## 数组常用 API 的时间复杂度和空间复杂度对比

<!-- notecardId: 1706284194654 -->

📢 参考答案：

| 方法      | 时间复杂度                 | 空间复杂度 |
| --------- | -------------------------- | ---------- |
| `push`    | O(1)                       | O(1)       |
| `pop`     | O(1)                       | O(1)       |
| `shift`   | **O(n)**（涉及元素的移动） | O(1)       |
| `unshift` | **O(n)**（涉及元素的移动） | O(1)       |
| `splice`  | **O(n)**（涉及元素的移动） | O(1)       |
| `slice`   | O(1)                       | O(n)       |
| `concat`  | O(1)                       | O(n)       |

以下是对每个方法的时间复杂度和空间复杂度的简要说明：

1. `push`：

   - 只是在数组末尾添加一个元素，**不会引起其他元素的移动**，所以时间复杂度为 O(1)
   - 因为 push 方法直接操作原数组，并**没有新增数组**，所以空间复杂度也为 O(1)

2. `pop`：

   - 只是从数组末尾移除一个元素，**不会引起其他元素的移动**，所以时间复杂度为 O(1)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

3. `shift`：

   - 从数组头部移除一个元素，因为**需要将剩余的元素往前移动以填补被删除的位置**，所以时间复杂度为 O(n)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

4. `unshift`：

   - 在数组头部添加一个元素，因为**需要将所有元素往后移动以填补腾出空间插入新元素**，所以时间复杂度为 O(n)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

5. `splice`：

   - 在指定位置插入或移除元素，因为**在插入或移除点之后的元素都需要被移动**，最坏的情况下，会移动所有元素，所以时间复杂度为 O(n)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

6. `slice`：

   - 从数组中提取一个子数组，**不会引起其他元素的移动**，所以时间复杂度为 O(1)
   - 因为需要复制数组的元素，**创建一个新数组**，最坏情况下，会复制整个数组，所以空间复杂度为 O(n)

7. `concat`：

   - 连接两个数组，**不会引起其他元素的移动**，所以时间复杂度为 O(n)
   - 对于 concat 方法，因为是**合并两个数组**，所以实际空间复杂度为 O(m + n)，其中 m 和 n 分别是两个数组的长度，**但是 n + m 与 n 一般为同一数量级，所以简化为 O(n)**

## 请介绍一下栈

<!-- notecardId: 1706284194659 -->

📢 参考答案：

### 定义

- 栈是一种**后进先出**的**有序集合**
- 分为**栈顶**和**栈底**，新增和移除元素**都在栈顶进行**
- 可以**类比为叠放在一起的盘子**，后放上去的盘子是栈顶，是最先被取走的
  ![](../Media/%E6%A0%88.png)

### 为什么需要

- 因为栈在计算机科学和编程当中**应用广泛**，例如：**历史记录**、**撤销功能**、**函数调用**等都是用栈来实现

### 基本使用

#### 1. 入栈

- 可以通过数组来保存栈内的元素，然后通过数组 **push** 方法来实现**入栈**

  ```javascript
  const stack = [];

  stack.push(5); // 将 5 入栈
  ```

#### 2. 出栈

- 可以通过数组的 **pop** 方法来实现**出栈**

  ```javascript
  const stack = [5];

  stack.pop(); // 将 5 出栈
  ```

### 使用注意

- 栈是一个**抽象的理论模型**，不管如何实现
- **数组只是实现栈的一种方式**，还可以通过链表等不同的数据结构实现栈
- 若要**频繁的中间插入或删除元素**，应该**选择链表**来实现栈，而是使用数组

## 数组与栈的区别

<!-- notecardId: 1706284194665 -->

📢 参考答案：

- **栈不是数组，数组也不是栈**
- 栈是一个**抽象的理论模型**，不管如何实现，不受制于任何语言，不同语言实现栈的方式不一样
- 数组是一个**具体功能的实现**，它受制于具体的编程语言
- 总之，**数组是实现栈的一种手段**，但是**栈无法实现数组**

## 请介绍一下队列

<!-- notecardId: 1706284194671 -->

📢 参考答案：

### 定义

- 队列是**先进先出**的**有序集合**
- 分为**入队**和**出队**，在**队尾新增元素**，在**队头移除元素**
- 可以**类比为排队**，越早排队越早离开，后来的要在队尾排队
  ![](../Media/%E9%98%9F%E5%88%97.png)

### 为什么需要

- 因为在计算机科学和编程中**应用广泛**，特别是在**需要按顺序处理数据或事件的情况下**，例如，异步操作中的任务队列，用于管理任务的先后顺序，按照接收的顺序依次执行

### 基本使用

#### 1. 入队

- 可以通过数组来保存队列内的元素，然后通过数组 **push** 方法来实现**入队**

  ```javascript
  const queue = [];

  queue.push(1); // 将 1 入队
  queue.push(2); // 将 2 入队
  ```

#### 2. 出队

- 可以通过数组的 **shift** 方法来实现**出栈**

  ```javascript
  const queue = [1, 2];

  queue.shift(); // 将 1 出队
  ```

### 使用注意

- 队列是一个**抽象的理论模型**，不管如何实现
- **数组只是实现栈的一种方式**，还可以通过链表等不同的数据结构实现队列
- 由于数组的 shift 方法时间复杂高，所以**选择链表**来实现队列，性能更好
