# Front-End-Interview::13-数据结构与算法::数据结构

## 请介绍一下算法复杂度

<!-- notecardId: 1706284194642 -->

🔍 所考察的知识点：

📢 参考答案：

### 定义

- 算法复杂度包含时间复杂度和空间复杂度，描述了程序被执行时，所需**计算量**和**内存空间**在**不同规模输入下的表现**

  > 注：**计算量，即执行时间，对应时间复杂度，内存空间对应空间复杂度**

- 算法复杂度**与代码书写是否简洁无关**

  > 注：例如，for 循环语句，循环 10 亿次，这样的代码**虽然书写上很简洁，但是所需的计算量惊人**

- 算法复杂度是**数量级**的，并不是具体的数字

  > 注：**同一单位为同一数量级**，例如，2 厘米与 8 厘米为同一数量级、2 厘米与 1 米 就是不同数量级

- 算法复杂度一般**针对一个具体的算法**，而不是一个完成系统的复杂度

  > 注：例如，算法复杂度**不管系统中网路的耗时、硬盘读取的耗时**，只考虑计算量和内存空间的耗时

### 为什么需要

- 因为有了算法复杂度，我们就可以估计**算法在不同规模数据输入下的表现**，有利于我们**了解算法的性能瓶颈**，以便**根据不同应用场景选择合适的算法处理问题**

### 基本使用

- 算法复杂度一般通过**大 O 表示法**来表示，常用的有 O(1)、O(log(n))、O(n)、O(nlog(n))、O(n^2) 等等

### 使用注意

1. 分析算法复杂度时，要关注**最坏情况下**的复杂度
2. 使用大 O 表示法时，最终结果**忽略掉常数因子和低阶项，只保留最高阶项**
   > 注：例如，如果基本操作执行次数为 3n^2 + 2n + 1，那么时间复杂度为 O(n^2)

## 请介绍一下大 O 表示法

<!-- notecardId: 1706284194648 -->

📢 参考答案：

### 定义

- 大 O 表示法是**表示算法复杂度的一种方法**，它**将算法按照所需计算量（即消耗时间）或者内存空间进行分类**

### 为什么需要

- 因为大 O 表示法提供了几类**函数**来表示不同算法的复杂度，有了它，你才能通过一种方式来**表示不同算法的复杂度**

### 常用大 O 表示符号

![](../Media/%E5%B8%B8%E7%94%A8%E5%A4%A7%20O%20%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%8F%B7.png)

### 基本使用

#### 常用的时间复杂度

1. **常数时间复杂度 O(1)**

   表示算法的**计算量是常数，与输入数据量无关**

   ```javascript
   function constantTime() {
     return [...arguments];
   }
   ```

   > 注：上述示例中，调用函数时，**不管传入多少数据，将 arguments 对象转换为数组）也只执行 1 次**，与输入数据量无关

2. **对数时间复杂度 O(log(n))**

   表示算法的**计算量与输入数据量成对数关系**，例如，输入 100 个数据，最坏情况下，计算量为 10 次

   ```javascript
   function binarySearch(arr, target) {
     let low = 0,
       high = arr.length - 1;
     while (low <= high) {
       let mid = Math.floor((low + high) / 2);
       if (arr[mid] === target) {
         return mid;
       } else if (arr[mid] < target) {
         low = mid + 1;
       } else {
         high = mid - 1;
       }
     }
     return -1;
   }
   ```

   > 注：上述示例是**二分查找算法**，是一个典型的对数时间复杂度例子，它通过二分查找算法**在有序数组中**查找目标元素，**每一次迭代都将候选范围减半**

3. **线性时间复杂度 O(n)**

   表示算法的**计算量与输入数据量一样**

   ```javascript
   function linearTime(arr) {
     arr.forEach((item) => {
       console.log(item);
     });
   }
   ```

   > 注：上述示例是**单层循环**，遍历数组的每一个元素，并对每个元素执行一次打印操作，数组元素有几个，就打印几次

4. **线性对数时间复杂度 O(nlog(n))**

   表示算法的**计算量与输入数据量呈线性对数关系**

   ```javascript
   function mergeSort(arr) {
     if (arr.length <= 1) {
       return arr;
     }
     const mid = Math.floor(arr.length / 2);
     const left = mergeSort(arr.slice(0, mid));
     const right = mergeSort(arr.slice(mid));
     return merge(left, right);
   }

   function merge(left, right) {
     let result = [];
     let i = 0,
       j = 0;
     while (i < left.length && j < right.length) {
       if (left[i] < right[j]) {
         result.push(left[i]);
         i++;
       } else {
         result.push(right[j]);
         j++;
       }
     }
     return result.concat(left.slice(i)).concat(right.slice(j));
   }
   ```

   > 注：上述示例是排序算法，是一个典型的线性对数时间复杂度，它包含**一个单层循环和一个二分法**，它将数组拆成两半，然后递归地对每一半进行排序，最后将它们合并，由于每次递归都将数组分为两半，所以时间复杂度为 nlog(n)

5. **平方时间复杂度 O(n^2)**

   表示算法的**计算量是输入数据量的平方**

   ```javascript
   function quadraticTime(matrix) {
     const rows = matrix.length;
     const cols = matrix[0].length;
     for (let i = 0; i < rows; i++) {
       for (let j = 0; j < cols; j++) {
         console.log(matrix[i][j]);
       }
     }
   }
   ```

   > 注：上述示例，使用**双层嵌套循环**来遍历二维矩阵，其中外层循环遍历行，内层循环遍历列，每层循环都会执行 n 次，所以总共是 `n * n = n^2`

#### 常用的空间复杂度

1. **常数空间复杂度 O(1)**
   表示算法所需的内存空间与输入数据量无关

   ```javascript
   function constantSpace(array) {
     let sum = 0;
     for (let i = 0; i < array.length; i++) {
       sum += array[i];
     }
     return sum;
   }
   ```

   > 注：上述例子中，**无论输入数组的大小如何**，我们**只需要一个额外的变量 `sum` 来存储总和**，所以空间复杂度是 O(1)。

2. **线性空间复杂度 O(n)**
   表示算法所需的内存空间随输入数据量线性增长

   ```javascript
   function linearSpace(arr) {
     let newArr = [];
     for (let i = 0; i < arr.length; i++) {
       newArr[i] = arr[i];
     }
     return newArr;
   }
   ```

   > 注：上述示例中，**传入数组的长度会影响到函数内返回值数组 newArr 的长度**，所需空间与传入数组的数据量成正比，因此，空间复杂度为 O(n)

### 使用注意

1. 写代码时，要**对算法复杂度敏感**，否则很容易出现编写的代码能实现功能，但是输入数据量一大，就崩溃的情况
2. **前端领域重时间轻空间**，所以要多关注时间复杂度，而空间复杂度一般是做嵌入式开发的人员要多关注的，因为搭载的小型系统内存小
3. 时间复杂度若为 **O(n^2)**，则该算法**不可用**

## 数组常用 API 的时间复杂度和空间复杂度对比

<!-- notecardId: 1706284194654 -->

📢 参考答案：

| 方法      | 时间复杂度                 | 空间复杂度 |
| --------- | -------------------------- | ---------- |
| `push`    | O(1)                       | O(1)       |
| `pop`     | O(1)                       | O(1)       |
| `shift`   | **O(n)**（涉及元素的移动） | O(1)       |
| `unshift` | **O(n)**（涉及元素的移动） | O(1)       |
| `splice`  | **O(n)**（涉及元素的移动） | O(1)       |
| `slice`   | O(1)                       | O(n)       |
| `concat`  | O(1)                       | O(n)       |

以下是对每个方法的时间复杂度和空间复杂度的简要说明：

1. `push`：

   - 只是在数组末尾添加一个元素，**不会引起其他元素的移动**，所以时间复杂度为 O(1)
   - 因为 push 方法直接操作原数组，并**没有新增数组**，所以空间复杂度也为 O(1)

2. `pop`：

   - 只是从数组末尾移除一个元素，**不会引起其他元素的移动**，所以时间复杂度为 O(1)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

3. `shift`：

   - 从数组头部移除一个元素，因为**需要将剩余的元素往前移动以填补被删除的位置**，所以时间复杂度为 O(n)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

4. `unshift`：

   - 在数组头部添加一个元素，因为**需要将所有元素往后移动以填补腾出空间插入新元素**，所以时间复杂度为 O(n)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

5. `splice`：

   - 在指定位置插入或移除元素，因为**在插入或移除点之后的元素都需要被移动**，最坏的情况下，会移动所有元素，所以时间复杂度为 O(n)
   - 空间复杂度也为 O(1)，**与 push 方法同理**

6. `slice`：

   - 从数组中提取一个子数组，**不会引起其他元素的移动**，所以时间复杂度为 O(1)
   - 因为需要复制数组的元素，**创建一个新数组**，最坏情况下，会复制整个数组，所以空间复杂度为 O(n)

7. `concat`：

   - 连接两个数组，**不会引起其他元素的移动**，所以时间复杂度为 O(n)
   - 对于 concat 方法，因为是**合并两个数组**，所以实际空间复杂度为 O(m + n)，其中 m 和 n 分别是两个数组的长度，**但是 n + m 与 n 一般为同一数量级，所以简化为 O(n)**

## 请介绍一下栈

<!-- notecardId: 1706284194659 -->

📢 参考答案：

### 定义

- 栈是一种**后进先出**的**有序集合**
- 分为**栈顶**和**栈底**，新增和移除元素**都在栈顶进行**
- 可以**类比为叠放在一起的盘子**，后放上去的盘子是栈顶，是最先被取走的
  ![](../Media/%E6%A0%88.png)

### 为什么需要

- 因为栈在计算机科学和编程当中**应用广泛**，例如：**历史记录**、**撤销功能**、**函数调用**等都是用栈来实现

### 基本使用

#### 1. 入栈

- 可以通过数组来保存栈内的元素，然后通过数组 **push** 方法来实现**入栈**

  ```javascript
  const stack = [];

  stack.push(5); // 将 5 入栈
  ```

#### 2. 出栈

- 可以通过数组的 **pop** 方法来实现**出栈**

  ```javascript
  const stack = [5];

  stack.pop(); // 将 5 出栈
  ```

### 使用注意

- 栈是一个**抽象的理论模型**，不管如何实现
- **数组只是实现栈的一种方式**，还可以通过链表等不同的数据结构实现栈

## 数组与栈的区别

<!-- notecardId: 1706284194665 -->

📢 参考答案：

- **栈不是数组，数组也不是栈**
- 栈是一个**抽象的理论模型**，不管如何实现，不受制于任何语言，不同语言实现栈的方式不一样
- 数组是一个**具体功能的实现**，它受制于具体的编程语言
- 总之，**数组是实现栈的一种手段**，但是**栈无法实现数组**

## 请介绍一下队列

<!-- notecardId: 1706284194671 -->

📢 参考答案：

### 定义

- 队列是**先进先出**的**有序集合**
- 分为**入队**和**出队**，在**队尾新增元素**，在**队头移除元素**
- 可以**类比为排队**，越早排队越早离开，后来的要在队尾排队
  ![](../Media/%E9%98%9F%E5%88%97.png)

### 为什么需要

- 因为在计算机科学和编程中**应用广泛**，特别是在**需要按顺序处理数据或事件的情况下**，例如，异步操作中的任务队列，用于管理任务的先后顺序，按照接收的顺序依次执行

### 基本使用

#### 1. 入队

- 可以通过数组来保存队列内的元素，然后通过数组 **push** 方法来实现**入队**

  ```javascript
  const queue = [];

  queue.push(1); // 将 1 入队
  queue.push(2); // 将 2 入队
  ```

#### 2. 出队

- 可以通过数组的 **shift** 方法来实现**出队**

  ```javascript
  const queue = [1, 2];

  queue.shift(); // 将 1 出队
  ```

### 使用注意

- 队列是一个**抽象的理论模型**，不管如何实现
- **数组只是实现队列的一种方式**，还可以通过链表等不同的数据结构实现队列
- 由于数组的 shift 方法时间复杂高，所以**选择链表**来实现队列，性能更好

## 请介绍一下链表

<!-- notecardId: 1706369576553 -->

📢 参考答案：

### 定义

- 链表是一种**有序**的数据结构，**按照插入的顺序排列**
- 它由**一系列节点**组成
- 每个节点由**数据元素本身**和**一个或多个指向其他节点的指针**组成
- 可以将链表类比为**火车**，数据元素本身类比为**车厢**，指针类比为车厢间的连接的**车钩**
  ![](../Media/%E9%93%BE%E8%A1%A8.png)

### 为什么需要

- **插入和删除操作更高效**

  在数组非末尾进行插入和删除操作，会导致其他元素的移动，效率较慢，而**链表只需修改指针即可实现，不会导致其他元素的移动**

  > 注：是否导致其他元素移动的原因是数组是**连续**存储元素的，**需要一段连续的内存空间**，而链表是**非连续**存储元素，所需的内存空间是零散的

### 基本使用

- 链表一般通过**对象**来模拟，例如，使用属性 **value** 来表示数据元素本身，使用 **next** 来表示指向下一个节点的指针

```javascript
const n1 = {
  value: 100,
  next: n2,
};

const n2 = {
  value: 100,
  next: n3,
};

const n3 = {
  value: 100,
  next: n4,
};

const n4 = {
  value: 100,
};
```

### 使用注意

1. 链表**无法**像数组那样**通过索引直接访问元素**，要访问某个元素，需要**从链表表头开始迭代查找**，比较耗时
2. 相比于数组，链表会**占用更多的内存空间**，因为每个节点还需要额外存储指针

## 链表和数组的异同点

<!-- notecardId: 1706369576560 -->

📢 参考答案：

### 相同点

- 都是**有序结构**

### 不同点

- 链表**查询慢**，时间复杂度为 **O(n)**，而数组**查询快**，时间复杂度为 **O(1)**
  > 注：因为链表**无法**像数组那样**通过索引直接访问元素**，要访问某个元素，需要**从链表表头开始迭代查找**，比较耗时
- 链表**新增和删除快**，时间复杂度为 **O(1)**，而数组**新增和删除慢**，时间复杂度为 **O(n)**
  > 注：因为在数组非末尾进行插入和删除操作，会导致其他元素的移动，效率较慢，而**链表只需修改指针即可实现，不会导致其他元素的移动**

## 链表和数组，哪个实现队列更快？

<!-- notecardId: 1706369576565 -->

📢 参考答案：

### 结论

- **链表**实现队列**更快**

### 分析

- 数组是**连续**存储，使用 push 入队很快，但是使用 shift **出队很慢**
- 链表是**非连续**存储，使用 add **入队**和 delete **出队都很快**（虽然查找很慢）

## 请介绍一下二分查找

<!-- notecardId: 1707788194602 -->

📢 参考答案：

### 定义

- 二分查找是一种在**有序数组**中查找目标元素的高效算法
- 它通过**比较**目标元素和数组中间元素的大小关系，来**判断**目标元素在左半边还是右半边，从而**缩小查找范围**

### 为什么需要

- 对于一个按照特定顺序（**递增/递减**）排列的数组，若使用遍历方法顺序查找，则时间复杂度为 **O(n)**，而使用二分查找，其时间复杂度为 **O(logn)**，当有**大规模输入数据**时，**二分查找的优势会非常明显**

### 基本使用

1. 创建两个指针，**左指针 left 和右指针 right**，分别指向数组的**头和尾**
2. 获取数组**中间元素**及其对应的**索引 mid**
3. **比较目标值与中间元素的大小关系**，若目标值**等于**中间元素，**则返回中间元素索引 mid**
4. 若目标值**小于**中间元素，则更新右边界 right 为 **mid - 1**，**继续在左半部分查找**
5. 若目标值**大于**中间元素，则更新左边界 left 为 **mid + 1**，**继续在右半部分查找**
6. 重复步骤 2-5，直到找到目标值或左边界大于右边界，表示未找到目标值

### 使用注意

- 二分查找**只针对**按照特定顺序（**递增/递减**）排列的数组
- 当**存在多个相同目标值时**，二分查找可能返回其中任意一个，**具体返回哪一个可能取决于实现方式**

## 循环和递归哪个好

<!-- notecardId: 1706454910093 -->

📢 参考答案：

1. 性能方面
   比起递归，**循环性能好一点**
2. 代码逻辑方面
   比起循环，**递归代码逻辑更加清晰**，书写也比较简洁

## 请介绍一下斐波那契数列

<!-- notecardId: 1706454910097 -->

📢 参考答案：

### 定义

- 斐波那契数列又称**黄金分割数列**，是以**兔子繁殖**为例子而引入的
- 它的**第一个数字是 0，第二个数字是 1，从第三个数字开始，每个数字是前两个数字之和**
  ![](../Media/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png)

### 为什么需要

- 因为它在数学和计算机科学等领域具有重要意义，例如：
  1. 它描述了自然现象，如**植物生长规律、动物繁殖规律**等
  2. 它常用于算法和编程，如**动态规划、递归**等
  3. 它也应用于金融，如**股票价格波动、经济增长**等

### 基本使用

- 斐波那契数列可以通过**递归**和**迭代**两种方式实现

### 使用注意

- 使用**递归**来实现斐波那契数列，虽然简洁易懂，但是**性能有问题**，当输入量一大，会**存在大量重复计算**，时间复杂度为 **O(2^n)**

## 请介绍一下动态规划

<!-- notecardId: 1706454910101 -->

📢 参考答案：

### 定义

- 动态规划是一种**算法设计方法**
- 它将问题分解为多个**相互重叠的子问题**，然后求解子问题，最终**将子问题的解组合起来得到原问题的解**

### 为什么需要

- 因为动态规划**特别适合求解最优化问题**，例如最短路径问题、最长公共子序列问题、背包问题等

### 基本使用

### 使用注意

- 动态规划是将问题分解为**相互重叠**的子问题，而分治法是将问题分解为**独立**的子问题
- 动态规划是**用递归的思想去分析问题**，然后**改用迭代来实现**
  > 注：若实现也用递归，会因为递归过程中存在大量计算，造成算法时间复杂度为 O(2^n)，不可用

## 请介绍一下二叉树

<!-- notecardId: 1706542768802 -->

📢 参考答案：

### 定义

- 二叉树是一种**树状**的数据结构
- 每个节点**最多只能有两个子节点**
- 每个节点由**一个数据元素**和**两个指向左右子节点的指针**组成

### 为什么需要

- 因为它**在查找、插入和删除等操作上具有较高的效率**，特别是在**二叉搜索树**（BST）内

### 基本使用

1. 创建二叉树
   二叉树使用对象来模拟，例如，使用属性 **value** 来表示数据元素本身，使用属性 **left** 来表示左子节点，使用属性 **right** 来表示右子节点

   ```javascript
   class TreeNode {
     constructor(value) {
       this.value = value;
       this.left = null;
       this.right = null;
     }
   }

   const root = new TreeNode(1);
   root.left = new TreeNode(2);
   root.right = new TreeNode(3);
   root.left.left = new TreeNode(4);
   root.left.right = new TreeNode(5);
   ```

2. 遍历二叉树
   二叉树遍历分为三种：**前序遍历、中序遍历、后序遍历**
   - 前序遍历
     指的是遍历顺序是 **root → left → right**
   - 中序遍历
     指的是遍历顺序是 **left → root → right**
   - 后序遍历
     指的是遍历顺序是 **left → right → root**
3. 查找二叉树
   指的是通过遍历来查找二叉树内的目标值

### 使用注意

- **二叉树和二叉搜索树（BST）不一样**，二叉搜索树是特殊的二叉树，它保持**左子节点 < 根节点 < 右子节点**
- **没有一个子节点**的根节点也称为**叶子节点**
- 对于二叉树，**只要拿到最上面的根节点，就可以知道整棵树**，与链表同理，链表只要拿到表头，就能知道整条链

## 请分别描述以下二叉树前序遍历、中序遍历、后序遍历的结果

![](../Media/%E4%BA%8C%E5%8F%89%E6%A0%91.png)

%

### 前序遍历

- **C B A D E G F H**

### 中序遍历

- **A B C E F G H D**

### 后序遍历

- **A B F H G E D C**

## 请介绍一下深度优先遍历、广度优先遍历

<!-- notecardId: 1706542768813 -->

📢 参考答案：

### 定义

1. 深度优先遍历：

   - 全称为 Depth-First Search（**DFS**）
   - 是一种**树的遍历算法**
   - 从根节点开始，沿着树的深度**尽可能远的搜索，直到遇到叶子节点为止**，然后回溯到上一层节点，继续深度优先遍历其他节点

2. 广度优先遍历：

   - 全称为 Breadth-First Search（**BFS**）
   - 也是一种树的遍历算法
   - 从根节点开始，沿着树**逐层遍历**，**先访问离起始节点最近的节点**，然后逐层扩展，直到遍历完整个树

   ![](../Media/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png)

### 为什么需要

### 基本使用

1. 深度优先遍历算法口诀：

   - 访问根节点
   - 对根节点的 children 挨个进行深度优先遍历

     ```javascript
     const tree = {
       value: 'a',
       children: [
         {
           value: 'b',
           children: [
             {
               value: 'd',
               children: [],
             },
             {
               value: 'e',
               children: [],
             },
           ],
         },
         {
           value: 'c',
           children: [
             {
               value: 'f',
               children: [],
             },
             {
               value: 'g',
               children: [],
             },
           ],
         },
       ],
     };

     function dfs(root) {
       if (root == null) return;
       // 访问根节点
       console.log(root.value);
       // 对根节点的 children 挨个进行深度优先遍历
       root.children.forEach(dfs);
     }

     dfs(tree);
     ```

2. 广度优先遍历：

   - 新建一个队列，把根节点入队
   - 把**队头出队**并访问
   - 把**队头的 children 挨个入队**
   - 重复第二、三步，直到队列为空

     ```javascript
     const tree = {
       value: 'a',
       children: [
         {
           value: 'b',
           children: [
             {
               value: 'd',
               children: [],
             },
             {
               value: 'e',
               children: [],
             },
           ],
         },
         {
           value: 'c',
           children: [
             {
               value: 'f',
               children: [],
             },
             {
               value: 'g',
               children: [],
             },
           ],
         },
       ],
     };

     function bfs(root) {
       // 新建一个队列，把根节点入队
       const q = [root];
       // 不断迭代，直到队列为空
       while (q.length) {
         // 队头出队
         const queueTop = q.shift();
         // 访问队头的值
         console.log(queueTop.value);
         // 把队头的 children 挨个入队
         queueTop.children.forEach((child) => {
           q.push(child);
         });
       }
     }

     bfs(tree);
     ```

### 使用注意

- 深度优先遍历一般使用**递归或者栈**来实现，而广度优先遍历一般使用**队列**来实现
- 深度优先遍历通常用于**查找路径、判断连通性**等场景，而广度优先遍历通常用于**寻找最短路径、层次遍历**等场景
