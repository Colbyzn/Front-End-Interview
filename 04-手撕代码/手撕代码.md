# Front-End-Interview::04-手撕代码

## 手写深拷贝

<!-- notecardId: 1702310914312 -->

📢 参考答案：

思路：

1. **判断要拷贝的对象类型**：若为值类型或者函数，则直接返回该值
2. **声明变量**：用于存储所拷贝对象
3. **处理数组**：若为数组，则初始化变量为 []，然后遍历数组，对数组内的每个元素调用 deepClone 函数（即**递归调用**）
4. **处理对象**：若为对象，则初始化变量为 {}，然后遍历对象，对对象内的每个**自有属性**（即非原型上的属性）调用 deepClone 函数（即**递归调用**）
5. **返回结果**

代码：

```javascript
function deepclone(obj) {
  if (typeof obj !== "object" || obj == null) return obj;

  let result;

  if (obj instanceof Array) {
    result = [];
    for (let i = 0, len = obj.length; i < len; i++) {
      result[i] = deepclone(obj[i]);
    }
  }

  if (obj instanceof Object) {
    result = {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepclone(obj[key]);
      }
    }
  }

  return result;
}
```

## 手写 call 函数

<!-- notecardId: 1702742490459 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myCall 方法**
   > 注：这样所有函数都可以公用该方法
2. **获取所传入的 this 对象**：若未传入，则取值为 Window 对象
3. **获取剩余参数**（除了第一项之外的参数）
4. **将调用 myCall 方法的函数（即 this）添加到所传入的 this 对象的 fn 属性上**
5. **使用所传入的 this 对象来调用 fn 函数**，并传入剩余参数
   > 注：这样函数 fn 中的 this 就会指向调用它的对象，即所传入的 this 对象
6. **删除新添加的 fn 属性**
   > 注：避免污染所传入的 this 对象
7. **返回**函数调用后的结果

代码：

```javascript
Function.prototype.myCall = function (context) {
  context = context || window;

  const args = [...arguments].slice(1);

  context.fn = this;

  const result = context.fn(...args);

  delete context.fn;

  return result;
};
```

> 注：当**实参个数多于形参**时，形参 context **只会获取所传入的第一个实参**，其余的实参会忽略

## 手写 apply 函数

<!-- notecardId: 1702742490463 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myCall 方法**
   > 注：这样所有函数都可以公用该方法
2. **获取所传入的 this 对象**和**参数数组**：若未传入，则 this 对象为 Window 对象，参数数组为 []
3. **将调用 myCall 方法的函数（即 this）添加到所传入的 this 对象的 fn 属性上**
4. **使用所传入的 this 对象来调用 fn 函数**，并传入剩余参数
   > 注：这样函数 fn 中的 this 就会指向调用它的对象，即所传入的 this 对象
5. **删除新添加的 fn 属性**
   > 注：避免污染所传入的 this 对象
6. **返回**函数调用后的结果

代码：

```javascript
Function.prototype.myApply = function (context, argsArr) {
  context = context || window;
  argsArr = argsArr || [];

  context.fn = this;

  const result = context.fn(...argsArr);

  delete context.fn;

  return result;
};
```

## 手写 bind 函数

<!-- notecardId: 1702742490467 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myBind 方法**
   > 注：以便所有函数都可以公用该方法
2. **获取所传入的 this 对象**：若未传入，则取值为 Window 对象
3. **获取剩余参数**（除了第一项之外的参数）
4. **获取调用 myBind 方法的函数**
5. **返回一个新函数**
6. 在新函数内，将所传入的 this 对象和参数**交给 apply 函数来处理，并返回处理后的结果**

```javascript
Function.prototype.myBind = function (context) {
  context = context || window;

  const argsArr = [...arguments].slice(1);

  const _this = this;

  return function () {
    return _this.apply(context, argsArr);
  };
};
```

## 手写 Promise 加载一张图片

<!-- notecardId: 1702829254286 -->

📢 参考答案：

思路：

1. 定义一个接受 url 参数的 loadImage 函数，并**返回一个新的 Promise**
2. 在返回的 Promise 中，**创建一个 img 元素**
3. 为 img 元素**绑定 onload 事件**，当图片加载成功时，调用 resolve 函数并传入 img 元素
4. 为 img 元素**绑定 onerror 事件**，当图片加载失败时，调用 reject 函数并传入一个包含错误提示的 Error 对象
5. 将传入的 url **赋值**给 img 元素 src 属性
6. 调用 loadImage 函数并传入图片的 url 返回 Promise 对象，然后调用该对象的 then 方法来处理成功的情况，catch 方法来处理错误的情况

代码：

```javascript
function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");

    img.onload = function () {
      resolve(img);
    };

    img.onerror = function () {
      reject(new Error(`图片加载失败 ${url}`));
    };

    img.src = url;
  });
}

const url =
  "https://foruda.gitee.com/avatar/1677103757503685327/7933519_colbyzn_1597326220.png!avatar200";
loadImage(url)
  .then((img) => {
    document.body.appendChild(img);
  })
  .catch((error) => {
    console.log(error);
  });
```
