# Front-End-Interview::04-手撕代码

## 手写深拷贝

<!-- notecardId: 1702310914312 -->

📢 参考答案：

思路：

1. **判断要拷贝的对象类型**：若为值类型或者函数，则直接返回该值
2. **声明变量**：用于存储所拷贝对象
3. **处理数组**：若为数组，则初始化变量为 []，然后遍历数组，对数组内的每个元素调用 deepClone 函数（即**递归调用**）
4. **处理对象**：若为对象，则初始化变量为 {}，然后遍历对象，对对象内的每个**自有属性**（即非原型上的属性）调用 deepClone 函数（即**递归调用**）
5. **返回结果**

代码：

```javascript
function deepclone(obj) {
  if (typeof obj !== "object" || obj == null) return obj;

  let result;

  if (obj instanceof Array) {
    result = [];
    for (let i = 0, len = obj.length; i < len; i++) {
      result[i] = deepclone(obj[i]);
    }
  }

  if (obj instanceof Object) {
    result = {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepclone(obj[key]);
      }
    }
  }

  return result;
}
```

## 手写 call 函数

<!-- notecardId: 1702742490459 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myCall 方法**
   > 注：这样所有函数都可以公用该方法
2. **获取所传入的 this 对象**：若未传入，则取值为 Window 对象
3. **将调用 myCall 方法的函数（即 this）添加到所传入的 this 对象的 fn 属性上**
4. **获取剩余参数**（除了第一项之外的参数）
5. **使用所传入的 this 对象来调用 fn 函数**，并传入剩余参数
   > 注：这样函数 fn 中的 this 就会指向调用它的对象，即所传入的 this 对象
6. **删除新添加的 fn 属性**
   > 注：避免污染所传入的 this 对象
7. **返回**函数调用后的结果

代码：

```javascript
Function.prototype.myCall = function (context) {
  context = context || window;

  context.fn = this;

  const args = [...arguments].slice(1);

  const result = context.fn(...args);

  delete context.fn;

  return result;
};
```

> 注：当**实参个数多于形参**时，形参 context **只会获取所传入的第一个实参**，其余的实参会忽略

## 手写 apply 函数

<!-- notecardId: 1702742490463 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myCall 方法**
   > 注：这样所有函数都可以公用该方法
2. **获取所传入的 this 对象**和**参数数组**：若未传入，则 this 对象为 Window 对象，参数数组为 []
3. **将调用 myCall 方法的函数（即 this）添加到所传入的 this 对象的 fn 属性上**
4. **使用所传入的 this 对象来调用 fn 函数**，并传入剩余参数
   > 注：这样函数 fn 中的 this 就会指向调用它的对象，即所传入的 this 对象
5. **删除新添加的 fn 属性**
   > 注：避免污染所传入的 this 对象
6. **返回**函数调用后的结果

代码：

```javascript
Function.prototype.myApply = function (context, argsArr) {
  context = context || window;
  argsArr = argsArr || [];

  context.fn = this;

  const result = context.fn(...argsArr);

  delete context.fn;

  return result;
};
```

## 手写 bind 函数

<!-- notecardId: 1702742490467 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myBind 方法**
   > 注：以便所有函数都可以公用该方法
2. **获取所传入的 this 对象**：若未传入，则取值为 Window 对象
3. **获取调用 myBind 方法的函数**
4. **获取剩余参数**（除了第一项之外的参数）
5. **返回一个新函数**
6. 在新函数内，将所传入的 this 对象和参数**交给 apply 函数来处理，并返回处理后的结果**

```javascript
Function.prototype.myBind = function (context) {
  context = context || window;

  const _this = this;

  const argsArr = [...arguments].slice(1);

  return function () {
    return _this.apply(context, argsArr);
  };
};
```
