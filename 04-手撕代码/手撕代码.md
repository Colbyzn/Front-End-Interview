# Front-End-Interview::04-手撕代码

## 手写深拷贝

<!-- notecardId: 1702310914312 -->

📢 参考答案：

思路：

1. **判断要拷贝的对象类型**：若为值类型或者函数，则直接返回该值
2. **声明变量**：用于存储所拷贝对象
3. **处理数组**：若为数组，则初始化变量为 []，然后遍历数组，对数组内的每个元素调用 deepClone 函数（即**递归调用**）
4. **处理对象**：若为对象，则初始化变量为 {}，然后遍历对象，对对象内的每个**自有属性**（即非原型上的属性）调用 deepClone 函数（即**递归调用**）
5. **返回结果**

代码：

```javascript
function deepclone(obj) {
  if (typeof obj !== "object" || obj == null) return obj;

  let result;

  if (obj instanceof Array) {
    result = [];
    for (let i = 0, len = obj.length; i < len; i++) {
      result[i] = deepclone(obj[i]);
    }
  }

  if (obj instanceof Object) {
    result = {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepclone(obj[key]);
      }
    }
  }

  return result;
}
```

## 手写 call 函数

<!-- notecardId: 1702742490459 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myCall 方法**
   > 注：这样所有函数都可以公用该方法
2. **获取所传入的 this 对象**：若未传入，则取值为 Window 对象
3. **获取剩余参数**（除了第一项之外的参数）
4. **将调用 myCall 方法的函数（即 this）添加到所传入的 this 对象的 fn 属性上**
5. **使用所传入的 this 对象来调用 fn 函数**，并传入剩余参数
   > 注：这样函数 fn 中的 this 就会指向调用它的对象，即所传入的 this 对象
6. **删除新添加的 fn 属性**
   > 注：避免污染所传入的 this 对象
7. **返回**函数调用后的结果

代码：

```javascript
Function.prototype.myCall = function (context) {
  context = context || window;

  const args = [...arguments].slice(1);

  context.fn = this;

  const result = context.fn(...args);

  delete context.fn;

  return result;
};
```

> 注：当**实参个数多于形参**时，形参 context **只会获取所传入的第一个实参**，其余的实参会忽略

## 手写 apply 函数

<!-- notecardId: 1702742490463 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myApply 方法**
   > 注：这样所有函数都可以公用该方法
2. **获取所传入的 this 对象**和**参数数组**：若未传入，则 this 对象为 Window 对象，参数数组为 []
3. **将调用 myApply 方法的函数（即 this）添加到所传入的 this 对象的 fn 属性上**
4. **使用所传入的 this 对象来调用 fn 函数**，并传入剩余参数
   > 注：这样函数 fn 中的 this 就会指向调用它的对象，即所传入的 this 对象
5. **删除新添加的 fn 属性**
   > 注：避免污染所传入的 this 对象
6. **返回**函数调用后的结果

代码：

```javascript
Function.prototype.myApply = function (context, argsArr) {
  context = context || window;
  argsArr = argsArr || [];

  context.fn = this;

  const result = context.fn(...argsArr);

  delete context.fn;

  return result;
};
```

## 手写 bind 函数

<!-- notecardId: 1702742490467 -->

📢 参考答案：

思路：

1. 往构造函数 Function 的**原型对象上添加 myBind 方法**
   > 注：以便所有函数都可以公用该方法
2. **获取所传入的 this 对象**：若未传入，则取值为 Window 对象
3. **获取剩余参数**（除了第一项之外的参数）
4. **获取调用 myBind 方法的函数**
5. **返回一个新函数**
6. 在新函数内，将所传入的 this 对象和参数**交给 apply 函数来处理，并返回处理后的结果**

```javascript
Function.prototype.myBind = function (context) {
  context = context || window;

  const argsArr = [...arguments].slice(1);

  const _this = this;

  return function () {
    return _this.apply(context, argsArr);
  };
};
```

## 手写 Promise 加载一张图片

<!-- notecardId: 1702829254286 -->

📢 参考答案：

思路：

1. 定义一个接受 url 参数的 loadImage 函数，并**返回一个新的 Promise**
2. 在返回的 Promise 中，**创建一个 img 元素**
3. 为 img 元素**绑定 onload 事件**，当图片加载成功时，调用 resolve 函数并传入 img 元素
4. 为 img 元素**绑定 onerror 事件**，当图片加载失败时，调用 reject 函数并传入一个包含错误提示的 Error 对象
5. 将传入的 url **赋值**给 img 元素 src 属性
6. 调用 loadImage 函数并传入图片的 url 返回 Promise 对象，然后调用该对象的 then 方法来处理成功的情况，catch 方法来处理错误的情况

代码：

```javascript
function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");

    img.onload = function () {
      resolve(img);
    };

    img.onerror = function () {
      reject(new Error(`图片加载失败 ${url}`));
    };

    img.src = url;
  });
}

const url =
  "https://foruda.gitee.com/avatar/1677103757503685327/7933519_colbyzn_1597326220.png!avatar200";
loadImage(url)
  .then((img) => {
    document.body.appendChild(img);
  })
  .catch((error) => {
    console.log(error);
  });
```

## 手写 Promise

<!-- notecardId: 1703175555593 -->

📢 参考答案：

思路：

1. **使用 class 声明一个名为 MyPromise 的类**
2. 在类中
   - 定义状态管理的相关属性，分别是 **state、value、reason、onFulfilledCallback、onRejectedCallback**
     > 注：
     > state → 存储当前 Promise 状态值
     > value → 存储 Promise 成功状态的结果值
     > reason → 存储 Promise 失败状态的结果值
     > onFulfilledCallback → 数组，存储 Promise 成功状态下要执行的回调函数
     > onRejectedCallback → 数组，存储 Promise 失败状态下要执行的回调函数
3. 在构造函数 constructor 内：
   1. **接受一个函数 fn 作为参数**
   2. **在 try catch 中调用 fn**，同时传入两个函数参数 resolve 和 reject
   3. 声明函数 resolve，在该函数内：
      - 当状态值为 pending 时，修改状态值为 fulfilled、修改结果值为所传入的值，以及执行所有成功回调函数
   4. 声明函数 reject，在该函数内：
      - 当状态值为 pending 时，修改状态值为 rejected、修改结果值为所传入的值，以及执行所有失败回调函数
4. 声明一个公有方法 then，在该方法内：
   1. 接受两个可选参数 onFulfilled 和 onRejected
   2. 判断两个参数是否为函数类型，**若不是，则使用默认函数替换**
   3. 返回一个新的 Promise 对象，在该对象内：
      1. **若状态值为 fulfilled**，则在 try catch 中调用 onFulfilled 函数，并传入当前 Promise 成功状态的结果值，以获取返回值，然后调用 resolve 函数，并将返回值传入，从而修改所返回新 Promise 对象的状态值和结果值
      2. **若状态值为 rejected**，则在 try catch 中调用 onRejected，并传入当前 Promise 失败状态的结果值，以获取返回值，然后调用 reject 函数，并将返回值传入，从而修改所返回新 Promise 对象的状态值和结果值
      3. **若状态值为 pending**，则将状态值为 fulfilled 和 rejected 所对应的执行代码包裹在函数内，并添加到相应的回调数组中，等待执行
         > 注：上述的状态值指的是**调用 then 方法的 Promise 对象的状态值**
5. 定义一个公有方法 catch，在该方法内：
   1. 接受一个参数 onRejected
   2. 将所传入的参数 onRejected **交给 then 方法处理**，并返回处理后的结果

代码：

```javascript
class MyPromise {
  // 公有属性
  state = "pending";
  value = undefined;
  reason = undefined;
  onFulfilledCallback = [];
  onRejectedCallback = [];

  // 构造函数
  constructor(fn) {
    const resolve = (value) => {
      if (this.state === "pending") {
        this.state = "fulfilled";
        this.value = value;
        this.onFulfilledCallback.forEach((fn) => fn());
      }
    };

    const reject = (reason) => {
      if (this.state === "pending") {
        this.state = "rejected";
        this.reason = reason;
        this.onRejectedCallback.forEach((fn) => fn());
      }
    };

    try {
      fn(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  // then 方法
  then(onFulfilled, onRejected) {
    onFulfilled =
      typeof onFulfilled === "function" ? onFulfilled : (value) => value;
    onRejected =
      typeof onRejected === "function" ? onRejected : (reason) => reason;

    return new MyPromise((resolve, reject) => {
      if (this.state === "fulfilled") {
        try {
          const newValue = onFulfilled(this.value);
          resolve(newValue);
        } catch (error) {
          reject(error);
        }
      }
      if (this.state === "rejected") {
        try {
          const newReason = onRejected(this.reason);
          reject(newReason);
        } catch (error) {
          reject(error);
        }
      }
      if (this.state === "pending") {
        this.onFulfilledCallback.push(() => {
          try {
            const newValue = onFulfilled(this.value);
            resolve(newValue);
          } catch (error) {
            reject(error);
          }
        });
        this.onRejectedCallback.push(() => {
          try {
            const newReason = onRejected(this.reason);
            resolve(newReason);
          } catch (error) {
            reject(error);
          }
        });
      }
    });
  }

  // catch 方法
  catch(onRejected) {
    return this.then(null, onRejected);
  }
}
```

## 手写 Promise.resolve()

<!-- notecardId: 1703175555604 -->

📢 参考答案：

思路：

1. 往构造函数 Promise 上**添加静态方法 MyResolve**
2. 该方法**接受一个参数 value**
3. 在方法内：根据参数 value 的类型，返回 Promise 对象
   1. 若为 **Promise 对象**，则直接返回
   2. 若为**非 Promise 对象**，则返回一个新的 Promise 对象，其状态值为 fulfilled，结果值为该非 Promise 对象

代码：

```javascript
Promise.MyPromise = (value) => {
  if (value instanceof Promise) {
    return value;
  }

  return new Promise((resolve, reject) => {
    resolve(value);
  });
};
```

## 手写 Promise.reject()

<!-- notecardId: 1703175555611 -->

📢 参考答案：

思路：

1. 往构造函数 Promise 上**添加静态方法 MyReject**
2. 该方法接受**一个参数 reason**
3. 在该方法内：
   - **不管 reason 类型是什么**，**始终返回**一个**新的 Promise 对象**，其状态值为 rejected，结果值为参数 reason

代码：

```javascript
Promise.MyReject = (reason) => {
  return new Promise((resolve, reject) => {
    reject(reason);
  });
};
```

## 手写 Promise.all()

<!-- notecardId: 1703175555617 -->

📢 参考答案：

思路：

1. 往构造函数上 Promise 上**添加静态方法 MyAll**
2. 该方法**接受一个参数数组 arr**，并**返回一个新的 Promise 对象**，在 Promise 对象内：
   1. **判断所传入参数类型**，若不是数组，则直接调用 reject 方法，并传入自定义类型错误提示，并返回
   2. 若为数组，则**定义相关变量**，分别是 resolvedCounter、resolvedValue、length
      > 注：
      > resolvedCounter → 用于存储成功状态的 Promise 对象数量
      > resolvedValue → 数组，用于存储所有成功状态 Promise 对象的结果值
      > length → 用于存储所传入的参数数组的长度
   3. **遍历**所传入的参数数组，为每个元素**添加 then 和 catch 方法**，分别用于处理成功和失败的情况
      > 注：使用 **Promise.resolve()** 将数组中非 Promise 对象的元素处理成 Promise 对象，以便可以调用 then 和 catch 方法
   4. 在 then 方法内：
      1. **存储**成功状态的 Promise 对象的**结果值**
      2. **累加**当前成功状态的 promise 对象**数量**
      3. 当所记录的成功状态 Promise 对象**数量等于**所传入参数数组的**长度**，就**调用 resolve 方法**，并**传入**所存储的所有**成功状态** Promise 对象的**结果值**
   5. 在 catch 方法内：
      - **调用 reject 方法**，并**传入失败状态**的 Promise 对象的**结果值**

代码：

```javascript
Promise.MyAll = (arr) => {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(arr)) {
      return reject(new TypeError("argument must be Array"));
    }

    let resolvedCounter = 0;
    const resolvedValue = [];
    const length = arr.length;

    arr.forEach((item) => {
      Promise.resolve(item)
        .then((data) => {
          resolvedValue.push(data);
          resolvedCounter++;
          if (resolvedCounter === length) {
            resolve(resolvedValue);
          }
        })
        .catch((error) => {
          reject(error);
        });
    });
  });
};
```

## 手写 Promise.race()

<!-- notecardId: 1703258725510 -->

📢 参考答案：

思路：

1. 在构造函数 Promise 上添加静态方法 MyRace
2. 该方法接受一个参数数组 arr
3. 该方法返回一个新的 Promise 对象，在该对象内：
   1. 判断所传入参数的类型，若不是数组，则直接调用 reject 方法，传入自定义类型错误提示，并返回
   2. 若为数组，则定义一个状态标记变量 isResolved，用于标记是否已经有成功的 Promise 对象
   3. 遍历所传入的参数数组，为每个元素添加 then 和 catch 方法，分别用于处理成功和失败的情况
      > 注：使用 Promise.resolve() 将数组中非 Promise 对象的元素处理成 Promise 对象，以便可以调用 then 和 catch 方法
   4. 在 then 方法内：
      - 若还没有成功的 Promise 对象，则调用 resolve 方法，并传入成功状态 Promise 对象的结果值，并将状态标记为 true
        > 注：之所以使用标记，是为了提高程序的性能，因为 race 方法只要第一个状态发生改变的 Promise 对象，之后的 Promise 对象没必要处理
   5. 在 catch 方法内：
      - 调用 reject 方法，并传入失败状态的 Promise 对象的结果值

代码：

```javascript
Promise.MyRace = (arr) => {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(arr)) {
      return reject(new TypeError("arguments must be array"));
    }

    let isResolved = false;

    arr.forEach((item) => {
      Promise.resolve(item)
        .then((value) => {
          if (!isResolved) {
            resolve(value);
            isResolved = true;
          }
        })
        .catch((error) => {
          reject(error);
        });
    });
  });
};
```
