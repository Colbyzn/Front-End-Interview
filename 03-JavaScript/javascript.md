# Front-End-Interview::03-JavaScript

## typeof 能判断哪些类型？

<!-- notecardId: 1702310824318 -->

🔍 所考察的知识点：数据类型、数据类型判断

📢 参考答案：

- 识别出除 null 以外的所有值类型：number string blooean undefind symbol
- 识别函数：funtion
- 识别引用类型：object (到此为止，无法再进一步区分出是数组、对象还是 null)

## 发生隐式类型转换的情况有哪些？

<!-- notecardId: 1702310824324 -->

🔍 所考察的知识点：隐式类型转换

📢 参考答案：

定义：隐式类型转换是指对**不同类型数据**进行运算时，编译器会**自动**将一个数据类型转换为另一个数据类型，以使运算能够顺利进行

按照转换类型分类：

1. 转换为 string 类型

   - **字符串拼接**
     当使用运算符 **+**，并且其**两侧存在 string 类型数据**时，则编译器内部会自动**将两侧非 string 类型转换为 string 类型**，再拼接

     ```javascript
     console.log(123 + "1"); // 1231
     ```

2. 转换为 boolean 类型

   - **if 判断**
     编译器内部会自动**将小括号内非 boolean 类型的表达式转换为 boolean 类型**，再进行判断

     ```javascript
     if (2)
     // 2 会被转换为 true
     ```

   - **逻辑运算(&& || !)**
     编译器内部会自动**将逻辑运算符两侧非 boolean 类型的表达式转换为 boolean 类型**，再进行运算

     ```javascript
     console.log(10 && 0); // 0
     // 内部做了 boolean 类型转换(10 转换为 true，0 转换为 false)，但实际上返回的是原始操作数的值 0
     ```

3. 转换为 number 类型

   - **自增和自减运算符(++/--)**
     若进行自增/自减的变量为非 number 类型，则编译器内部会自动**将变量转换为 number 类型**，再运算

     ```javascript
     let num = "10";
     num++;
     console.log(num); // 11
     ```

   - **算数运算符(+ - \* / %)**
     编译器内部会自动将算数运算符两侧非 number 类型的数据转换为 number 类型

     ```javascript
     console.log(true + 1); // 2
     console.log("12" / 4); // 3
     ```

     > 注：对于 **+** 运算符，**只要两侧存在 string 类型的数据**，则**不会**将其隐式转换为 number 类型

   - **比较运算符(>, <, <=, >=, ==, !=)**
     编译器内部会自动**将比较运算符两侧非 number 类型的数据转换为 number 类型**

     ```javascript
     console.log("5" > 1); // true
     console.log("12" == 12); // true
     ```

## 何时使用 === 何时使用 ==？

<!-- notecardId: 1702310824328 -->

🔍 所考察的知识点：比较运算符、隐式类型转换

📢 参考答案：

除了判断是否等于 null 之外，一律用三等

> 注：判等运算符(==)，在进行比较前，会先转换成相同类型，再比较

## if (obj.a == null) 相当于什么？

<!-- notecardId: 1702310824332 -->

相当于：

```javascript
if (obj.a === null || obj.a === undefined)
```

> 注：实际开发中，常用 `if (obj.a == null)` 来简化写法

## 值类型和引用类型的区别？

<!-- notecardId: 1702310824335 -->

在 JavaScript 中，值类型和引用类型的区别主要体现在存储、复制和比较这三个方面：

1. **存储**：

   - 值类型：值类型的变量直接在栈中存储**实际的数据**。
     > 例如，如果你有一个变量`let a = 10;`，那么`a`就直接存储了数值`10`。
   - 引用类型：引用类型的变量存储的是**数据的引用**（也就是内存地址），而实际数据存放在堆中。
     > 例如，如果你有一个对象`let obj = {name: 'John'};`，那么`obj`存储的是这个对象在内存中的地址。

2. **复制**：

   - 值类型：当一个值类型的变量被赋值给另一个变量时，实际上是把值复制了一份给新的变量。
     > 例如，`let b = a;`，此时`b`会得到`a`的值`10`，`a`和`b`在内存中是**独立**的，**修改其中一个不会影响另一个**。
   - 引用类型：当一个引用类型的变量被赋值给另一个变量时，复制的是引用，因此两个变量指向内存中的同一个对象。
     > 例如，`let obj2 = obj;`，此时`obj2`和`obj`都**指向同一个对象**，**修改其中一个会影响另一个**。

3. **比较**：
   - 值类型：值类型之间比较的是它们的**实际值**。
     > 例如，`let a = 10; let b = 10;`，`a`和`b`是相等的，因为它们的值都是`10`。
   - 引用类型：引用类型之间比较的是它们的**引用地址**。若两个对象引用地址不一样，即使它们的内容完全相同，它们也不相等。
     > 例如，`let obj1 = {name: 'John'}; let obj2 = {name: 'John'};`，尽管`obj1`和`obj2`的内容相同，但它们是不相等的，因为它们在内存中是两个不同的对象。
