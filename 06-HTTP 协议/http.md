# Front-End-Interview::06-HTTP 协议

## 请介绍一下 HTTP 协议

<!-- notecardId: 1703606111357 -->

📢 参考答案：

### HTTP 协议的定义

- HTTP 全称为 Hyper Text Transfer Protocol（超文本传输协议），指的是客户端与服务端进行资源（文本、图像、音频、视频等）传输时，**通信双方所要遵守的一种通信格式**，也称为通讯协议
  > 注：**就好比信封的填写规则就是一种通信协议**，它要求发信人和回信人都得遵循信封的填写规则

### HTTP 协议的目的

- **保证通信可以顺利完成**

### HTTP 协议的交互模型

- 采用**请求-响应**的交互模型，即客户端发出一个请求，服务器返回一个响应

### HTTP 协议的特点

1. **无连接**

   - 指的是服务器**处理完客户端的请求**，并收到客户端的应答后，**立即断开连接**

2. **无状态**

   - 指的是服务器**不会记住**每次 HTTP **请求的状态信息**
     > 注：HTTP 的无状态性就好比去超市消费，若没有会员卡，则消费之后，超市不会有我们的任何消费信息，要想让服务器记住用户的状态，这时就需要使用到 Cookie 或 Session 等身份验证技术

3. **支持传输任何类型的数据**

   - HTTP **支持发送任何类型的数据**，只需要在 HTTP 头中加入正确的 MIME 类型
     > 注：**MIME 类型是一种标识数据类型的标准**，例如对于图片可以使用 "image/jpeg"、对于音频可以使用 "audio/mp3"

## 请介绍一下 HTTP 响应状态码

<!-- notecardId: 1703606111367 -->

📢 参考答案：

### HTTP 响应状态码的定义

- 指的是服务器返回给客户端的一个**三位数字代码**，用于**表示服务器处理客户端请求的结果**

### HTTP 响应状态码的组成

- **由 3 个十进制数组成**，第一个数字表示响应状态码的类型，其取值范围为 [1, 5]

### HTTP 响应状态码的分类

| 状态码 | 类别             | 描述                                                             |
| ------ | ---------------- | ---------------------------------------------------------------- |
| 1xx    | 信息性状态码     | 这类状态码表示客户端的**请求已被接收，正在处理**                 |
| 2xx    | 成功状态码       | 这类状态码表示客户端的**请求被成功接收、理解和处理**             |
| 3xx    | 重定向状态码     | 这类状态码表示客户端**需要进一步处理，才能完成请求**             |
| 4xx    | 客户端错误状态码 | 这类状态码表示客户端发送的**请求存在问题**，从而导致这次请求失败 |
| 5xx    | 服务器错误状态码 | 这类状态码表示处理请求时，**服务器发生错误**                     |

### 常见 HTTP 响应状态码

| 状态码                    | 含义                                                                                                                               |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| 200 OK                    | 请求**成功**                                                                                                                       |
| 301 Moved Permanently     | 请求的资源已**永久重定向**到新的地址<br>注：服务器会在**响应头部**中返回 **Location** 属性，其值为新 url，浏览器会自动跳转到新 url |
| 302 Found                 | 请求的资源**临时重定向**到新的地址<br>注：服务器会在**响应头部**中返回 **Location** 属性，其值为新 url，浏览器会自动跳转到新 url   |
| 304 Not Modified          | 请求的**资源未修改过**，客户端可以直接使用本地已缓存的资源                                                                         |
| 400 Bad Request           | 请求消息中存在**语法错误**，导致服务器无法解析该请求                                                                               |
| 401 Unauthorized          | 请求**没有进行身份验证或验证未通过**                                                                                               |
| 403 Forbidden             | 禁止访问，客户端**权限不够**                                                                                                       |
| 404 Not Found             | 所请求的**资源不存在**，服务器找不到                                                                                               |
| 500 Internal Server Error | 服务器**内部发生未知错误**，无法完成请求                                                                                           |
| 501 Not Implemented       | 服务器**不支持该请求方法**                                                                                                         |
| 503 Service Unavailable   | 服务器目前**暂时无法处理请求**，可能是过载或维护                                                                                   |
| 504 Gateway Timeout       | 服务器在等待上游服务器的响应时超时了，即**响应网关超时**                                                                           |

## 请介绍一下 HTTP 请求方法

<!-- notecardId: 1703606111374 -->

📢 参考答案：

### HTTP 请求方法的作用

- **告诉服务器要对资源进行何种操作**

### 常用的请求方法

1. GET

   - 用于**获取**服务器的资源

2. POST

   - 用于向服务器**新增**资源。
     > 注：多次发送**相同的 POST 请求**可能会导致服务器上**创建多个相同的资源**

3. PUT

   - 用于**更新**服务器上指定的资源
     > 注：多次发送相同的 PUT 请求会对资源进行相同的更新

4. DELETE

   - 用于**删除**服务器上指定的资源

## 什么是 Restful API？

<!-- notecardId: 1703606111380 -->

📢 参考答案：

### Restful API 的定义

- 指的是一种设计前后端数据访问接口的新方法，它**将每个 url 当作一个唯一的资源**，**通过请求方法来区分操作**

### 与传统 API 设计的区别

- **传统 API 设计将每个 url 当做一个功能**，而 Restful API 设计则是将每个 url 当做一个唯一的资源，并通过不同的请求方法来区分操作，示例图如下：
  ![](../Media/Restful%20API%20%E4%B8%8E%E4%BC%A0%E7%BB%9F%20API%20%E7%9A%84%E5%8C%BA%E5%88%AB.png)

## HTTP 中常见的 header 有哪些？

<!-- notecardId: 1703606111386 -->

### 常见的请求头部（Request Headers）

- Accept：浏览器**可接收的数据类型**，如 text/html、application/xml 等
- Accept-Encoding：浏览器**可接收的压缩算法**，如 gzip
- Accept-Language：浏览器**可接收的语言**，如 zh-CN
- Connection: **控制客户端和服务器之间的连接行为**，若值为 **keep-alive**，则**表示保持持久连接**，即一次 TCP 连接重复使用
- cookie：客户端存储的 cookie 字符串
- Host：请求的**域名**
- User-Agent：(UA)**浏览器信息**
- Content-Type：发送数据的格式，如 application/json

### 常见的响应头部（Response Headers）

- Content-Type：**返回的数据类型**，如 application/json
- Content-length：**返回的数据大小**，单位为字节
- Content-Encoding：**返回的数据压缩算法**，如 gzip
- Set-Cookie：**用于服务端设置客户端的 cookie**
- Location：用于**重定向到另一个 URL**

### 常见的缓存相关头部（Cache-Control Headers）

1. 请求头部内
   - If-Modified-Since：询问自**指定时间后**资源**是否被修改**
   - If-None-Match：询问资源的 **ETag 是否发生变化**
2. 响应头部内
   - Cache-Control：用于**控制客户端的缓存的行为**
   - Expires：设置缓存过期时间
     > 注：Expires 属于**旧标准**，功能**已被 Catch-Control 代替**
   - Last-Modified：资源**最后被修改的时间**
   - Etag：资源的**特定版本的标识符**，表示资源的**唯一性**

## 请介绍一下 HTTP 缓存

<!-- notecardId: 1703606111393 -->

📢 参考答案：

### 什么是 HTTP 缓存？

- 指的是**将先前服务器所返回的资源缓存起来**，当请求相同资源时，**若所缓存的资源仍然有效，则直接使用缓存中的资源**，服务器无需再返回资源

### 为什么需要缓存？

1. **提高页面加载速度**
   - 这是因为缓存避免了对相同资源进行请求，客户端可以直接使用缓存中的资源，省去了请求和响应的时间
2. **减轻服务器负载**
   - 这是因为客户端直接使用了缓存中的资源，服务器就无需再次传输相同的资源

### 哪些资源可以被缓存？

1. **静态资源**
   - 如 HTML 文档、CSS 样式表、JavaScript 脚本、图像文件等
2. **媒体文件**
   - 如音频文件、视频文件等
3. **字体文件**
   - 如字体文件（.ttf、.woff 等）

### 缓存的分类

1. 强制缓存

   - 定义
     - 指的是**服务器通过设置响应头部的缓存相关字段**（如 Cache-Control、Expires）来**控制客户端是否可以缓存该资源以及缓存的有效期限**
   - 强制缓存头部字段 Cache-Control
     - 作用
       - 用于**控制客户端的缓存的行为**
     - 位置
       - 响应头部内
     - 取值
       - max-age：设置缓存的**最大过期时间**，以秒为单位
       - no-cache：本地**不使用强制缓存，但是可以用服务端的缓存策略（如协商缓存）**
       - no-store：本地**不使用强制缓存，也不让服务端做缓存（如协商缓存）**，即每次都要求服务器端返回资源
       - public：表示响应数据可以**被任何设备缓存**（包括客户端和代理服务器）
       - private：表示响应**只能被客户端缓存**，不允许中间代理服务器缓存
   - 强制缓存过程
     1. **初次请求**，服务器**返回资源和 Cache-Control**
        > 注：服务器会根据资源是否应该被缓存，来决定是否返回 Cache-Control
     2. **再次请求**时，浏览器会根据 Cache-Control 所设置的值，**判断资源是否过期**，若没有过期，则直接访问本地缓存，否则，再向服务器请求资源
        ![](../Media/HTTP%20%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98.png)

2. 协商缓存

   - 定义

     - 指的是当客户端的**缓存过期**后，由服务器端通过**比较资源的标识符**来决定**是否返回资源**，若客户端和服务器端的资源标识符一致，则只返回 304 状态码，否则，返回 200 状态码、最新资源及其标识符
       > 注：
       >
       > 1. **只有当缓存过期了，才会进行协商缓存**，若缓存**没有过期**，即使服务器端更新了资源，客户端**依然会使用本地缓存**，不会向服务器端发送资源标识符进行协商缓存
       > 2. 资源标识符有两种：① **Last-Modified** ② **Etag**（若同时存在，则浏览器会**优先使用 Etage**，因为 Last-Modified 只能精确到秒级，如果资源在单位秒内被重复生成，而内容不变，则 Etag 更精确）

   - 协商缓存头部字段
     1. 请求头部内
        - If-Modified-Since：询问自**指定时间后**资源**是否被修改**
        - If-None-Match：询问资源的 **ETag 是否发生变化**
     2. 响应头部内
        - Last-Modified：资源**最后被修改的时间**
        - Etag：资源的**特定版本的标识符**，表示资源的**唯一性**
   - 协商缓存过程
     - 以 Last-Modified 为资源标识符的协商缓存过程
       1. 初次请求，服务器**返回资源**和头部字段 **Last-Modified**
       2. 客户端接收后，将资源缓存在本地
       3. 当本地**缓存过期**了，客户端会在请求头部中**携带 If-Modified-Since 字段**，其值为上次服务端返回的 Last-Modified 字段的值
       4. 若字段 If-Modified-Since 的值**与服务器端的一致**，则服务器端**只返回状态码 304**，否则，返回 200 状态码、最新资源以及新的 Last-Modified 标识符
          ![](../Media/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%20Last-Modified.png)
     - 以 Etag 为资源标识符的协商缓存过程
       1. 初次请求，服务器**返回资源**和头部字段 **Etag**
       2. 客户端接收后，将资源缓存在本地
       3. 当本地**缓存过期**了，客户端会在请求头部中**携带 If-None-Match 字段**，其值为上次服务端返回的 Etag 字段的值
       4. 若字段 If-None-Match 的值**与服务器端的一致**，则服务器端**只返回状态码 304**，否则，返回 200 状态码、最新资源以及新的 Etag 标识符
          ![](../Media/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%20Etag.png)

### 刷新操作方式，对缓存的影响

- 不同的刷新方式，会改变浏览器的缓存策略
  | 操作方式 | 场景 | 强制缓存 | 协商缓存 |
  | -------------- | --------------------- | -------- | -------- |
  | 正常操作 | ① 地址输入 URL ② 跳转链接 ③ 前进后退 | 有效 | 有效 |
  | **手动刷新** | ① 按 F5 ② 点击刷新按钮 ③ 右键菜单点击刷新 | **失效** | 有效 |
  | **强制刷新** | 按下  Ctrl + F5 | **失效** | **失效** |

### HTTP 缓存整体流程图

- 整体流程图包含强制缓存和协商缓存
  ![](../Media/HTTP%20%E7%BC%93%E5%AD%98%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

## 请介绍一下 HTTPS

<!-- notecardId: 1703694145019 -->

📢 参考答案：

### HTTPS 的定义

- HTTPS 全称为 Hyper Text Transfer Protocol Secure（**超文本传输安全协议**），是 HTTP 协议的**加密版本**，它**使用 SSL 或 TLS 协议来加密**客户端和服务器之间所有的通信，保证通信的安全性

### 为什么需要 HTTPS

- 之所以需要 HTTPS，是因为在**传统的 HTTP 协议**中，所有的数据都是**明文传输**的，很**不安全**，攻击者可以通过**中间人攻击**等手段，**获取通信过程中的敏感信息**，而 HTTPS 对通信进行了加密，可以防止中间人攻击
  > 注：中间人攻击指的是攻击者可以**拦截通信双方的传输内容**，并且可以任意修改内容

### HTTPS 的加密方案

- HTTPS 采用「**非对称加密 + 对称加密 + https 证书**」的加密方案
  > 注：
  >
  > 1. 非对称加密指的是使用**一对密钥**进行加密和解密，公钥用于加密，密钥用于解密，**速度较慢**，**不适合处理大量数据**
  > 2. 对称加密指的是使用**同一密钥**进行加密和解密，**速度较快**，**适合处理大量数据**
  > 3. 之所以要结合三种方法进行加密，是因为:
  >    1. 若只使用「**非对称加密**」，虽然**可以保证安全性**，不受中间人攻击，但是非对称加密的**计算成本高**，比起对称加密要慢得多，因此，**不适合加密大量数据**，而实际通信中，难免需要传输大量数据，所以该方案不合适
  >    2. 若只使用「**对称加密**」，虽然**计算成本低**，**可以加密大量数据**，但是**无法保证安全性**，攻击者可以截获通信传输过程中的密钥和加密内容，然后使用所截获的密钥对加密内容进行解密，实现中间人攻击
  >    3. 若使用「**非对称加密 + 对称加密**」，使用非对称加密来加密对称密钥，然后使用对称密钥来加密实际传输的大量数据，虽然结合了两者的优点，但是**无法保证安全性**，**攻击者可以将服务器端发送给客户端的非对称加密的公钥替换成自己的公钥**，这样客户端就使用了攻击者的公钥来加密对称密钥，之后，攻击者**截获该加密后的对称密钥，并使用自己密钥来解密**，从而实现中间人攻击
  >    4. 若使用「**非对称加密 + 对称加密 + https 证书**」，当服务器向客户端发送其公钥时，也会**一并发送数字证书**（通常由受信任的第三方证书颁发机构签发），**客户端验证这个证书，确保公钥确实来自预期的服务器，而不是中间人**，这种方案既保证了传输数据的加密效率，又保证了通信的安全性
  > 4. 总而言之，HTTPS 证书**保证了客户端的公钥来自服务器端**，而不是中间人，非对称加密**保证了对称密钥交换的安全性**，而对称加密**保证了传输数据加密和解密的效率**，三种方法环环相扣，缺一不可

### HTTPS 的加密流程

1. 客户端向服务器发起 HTTPS 请求
2. 服务器**返回数字证书**，其中包含服务器的公钥
3. 客户端**验证数字证书的合法性**，包括证书的有效性、签发机构等
4. 客户端**生成随机的对称密钥 KEY**，并使用服务器的**公钥进行加密**，然后发送给服务器
5. 服务器使用**私钥解密**得到对称密钥 KEY
6. 客户端和服务器**使用对称密钥 KEY 对传输数据进行加密和解密**
7. 数据传输完成后，连接关闭
   ![](../Media/HTTPS%20%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B.png)
